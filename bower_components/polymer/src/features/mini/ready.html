<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<script>

  /**
   * Provides `ready` lifecycle callback which is called parent to child.
   *
   * This can be useful in a number of cases. Here are some examples:
   *
   * Setting a default property value that should have a side effect: To ensure
   * the side effect, an element must set a default value no sooner than
   * `created`; however, since `created` flows child to host, this is before the
   * host has had a chance to set a property value on the child. The `ready`
   * method solves this problem since it's called host to child.
   *
   * Dom distribution: To support reprojection efficiently, it's important to 
   * distribute from host to child in one shot. The `attachedCallback` mostly
   * goes in the desired order except for elements that are in dom to start; in
   * this case, all children are attached before the host element. Ready also
   * addresses this case since it's guaranteed to be called host to child.
   *
   * @class standard feature: ready
   */

(function() {

  var baseAttachedCallback = Polymer.Base.attachedCallback;
  var baseDetachedCallback = Polymer.Base.detachedCallback;

  Polymer.Base.addFeature({

    hostStack: [],
    _readied: false,
    _attachedPending: false,

    // for overriding
    configure: function() {
    },

    // for overriding
    ready: function() {
    },

    queryHost: function(node) {
      return this.host || this._queryHost(this);
    },

    _queryHost: function(node) {
      return node && 
        (node.host || (node.host = this._queryHost(Polymer.dom(node).parentNode)));
    },

    // 1. set this element's `host` and push this element onto the `host`'s
    // list of `client` elements
    // 2. establish this element as the current hosting element (allows 
    // any elements we stamp to easily set host to us).
    _pushHost: function() {
      this.host = Polymer.Base.hostStack[Polymer.Base.hostStack.length-1];
      this._addToHost();
      if (!this._clients) {
        this._clients = [];
      }
      this._beginHost();
    },

    _beginHost: function() {
      Polymer.Base.hostStack.push(this);
    },

    _popHost: function() {
      // this element is no longer the current hosting element
      Polymer.Base.hostStack.pop();
    },

    _addToHost: function() {
      if (!this.host) {
        this.host = this.queryHost();
      }
      if (this.host) {
        this.host._clients.push(this);
      }
    },

    _removeFromHost: function() {
      if (this.host) {
        // TODO (sorvell): slow lookup, could use linked list instead
        // since we don't need random access.
        var i = this.host._clients.indexOf(this);
        if (i >= 0) {
          this.host._clients.splice(i, 1);
        }
        this.host = null;
      }
    },

    _readyContent: function() {
      if (this._canReady()) {
        this._initializeContent();
      }
    },

    _canReady: function() {
      return !this._readied && (!this.host || this.host._readied);
    },

    _initializeContent: function() {
      // prepare root
      this._setupRoot();
      // logically distribute self
      this._beginDistribute();
      // send data configuration signal
      this._configure();
      // now fully prepare localChildren
      var c$ = this._getDistributionClients();
      for (var i=0, l= c$.length, c; (i<l) && (c=c$[i]); i++) {
        c._initializeContent();
      }
      // perform actual dom composition
      this._finishDistribute();
      // send ready signal
      this._ready();
    },

    // calls `configure`
    // note: called host -> localChild
    _configure: function() {
      this.configure();
    },

    // mark readied and call `ready`
    // note: called localChildren -> host
    _ready: function() {
      this._readied = true;
      this._beforeReady();
      this.ready();
      if (this._attachedPending) {
        this._attachedPending = false;
        this.attachedCallback();
      }
    },

    // for system overriding
    _beforeReady: function() {},

    // normalize lifecycle: ensure attached occurs only after ready.
    attachedCallback: function() {
      // avoids redoing work done via creation
      if (!this.host) {
        this._addToHost();
      }
      if (this._readied) {
        baseAttachedCallback.call(this);
      } else {
        this._attachedPending = true;
      }
    },

    detachedCallback: function() {
      baseDetachedCallback.call(this);
      this._removeFromHost();
    }

  });

})();

</script>
